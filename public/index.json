[{"content":"This is the second part of the Portfolio Optimization with Python series. In Part I, we introduced the Portfolio Optimization field, the MVO framework and the MOSEK python API for solving a constrained portfolio optimization problem efficiently. This time, we will find the portfolio that maximizes a performance metric called Sharpe Ratio. We will first introduce the Sharpe Ratio and its benefits and drawbacks as a portfolio performance metric. Finally, we will formulate the optimization problem theoretically as a conic problem and solve it using Python.\nSharpe Ratio Developed by Nobel laureate William F. Sharpe in 1966, the Sharpe Ratio serves as a cornerstone for portfolio evaluation and comparison. This metric enables investors to assess the risk-adjusted return of a portfolio, providing a comprehensive measure of its efficiency. By incorporating both the returns and volatility of a portfolio, the Sharpe Ratio assists investors in making informed decisions, aiming to maximize returns while minimizing risk.\nThe Sharpe Ratio is defined as the ratio of the excess return of an investment over the risk-free rate to the standard deviation of the investment\u0026rsquo;s returns. Mathematically, the formula is expressed as:\n\\[ SR = \\dfrac{R_{p} - R_{f}}{\\sigma_{p}}, \\]\nwhere:\n\\(SR\\) is the Sharpe Ratio. \\(R_{p}\\) denotes the portfolio\u0026rsquo;s expected return. \\(R_{f}\\) signifies the risk-free rate of return. \\(\\sigma_{p}\\) represents the standard deviation of the portfolio\u0026rsquo;s returns. We can rewrite this formula in terms of the portfolio weights \\(\\mathbf{x}\\), the expected return vector \\(\\mathbf{\\mu}\\) and the covariance matrix \\(\\Sigma\\) as follows:\n\\[SR = \\dfrac{\\mathbf{\\mu}^{T}\\mathbf{x} - r_{f}}{\\sqrt{\\mathbf{x}^{T}\\Sigma \\mathbf{x}}}\\]\nBenefits The benefits of using the Sharpe Ratio are:\nRisk-adjusted Performance: the Sharpe Ratio provides a more comprehensive assessment of portfolio performance. It accounts for the inherent risk associated with investments and helps investors evaluate the potential rewards relative to the level of risk undertaken. Comparative Analysis: the Sharpe Ratio allows for straightforward comparisons between different investment portfolios by assessing their risk-adjusted returns. Decision Support: this metric aids in decision-making by quantifying the trade-off between returns and risk. An investor can utilize the Sharpe Ratio to identify portfolios with higher expected returns per unit of risk. Drawbacks Assumptions of Normality: the Sharpe Ratio assumes that returns follow a normal distribution, which might not always be the case in real-world scenarios. Sensitivity to Risk-Free Rate: The choice of an appropriate risk-free rate can significantly impact the Sharpe Ratio. The risk-free rate acts as a benchmark, representing the return an investor would earn from a riskless investment. However, different market conditions and varying interpretations of the risk-free rate can introduce subjectivity and affect the interpretation of the Sharpe Ratio. Dependency on Historical Data: the Sharpe Ratio relies on historical data to estimate the average returns and standard deviation of a portfolio. Consequently, it assumes that past performance is indicative of future outcomes. While it may not be possible to completely eliminate the drawbacks of the Sharpe Ratio, several approaches can help to mitigate their impact and enhance metric\u0026rsquo;s effectiveness. Although we will not focus on these approaches, here are some strategies to address the drawbacks mentioned above:\nUse other risk-adjusted metrics that are more suitable for modeling non-normal return distributions, such as the Sortino Ratio or the Omega Ratio, which account for downside risk and skweness in return distributions. Incorporate Stress Testing and Scenario Analysis to account for extreme market events and analyze portfolio performance in adverse market conditions. This approach can help to refine the risk management strategies. Use Robust Portfolio Optimization techniques to incorporate uncertainty by considering a range of potential scenarios, minimizing the impact of extreme events and improving the reliability of risk and return estimates. Conic Formulation The idea now is to use the Sharpe Ratio metric as the objective function in our optimization problem. In this way, the objective function of the portfolio optimization algorithm is\n\\[\\text{maximize}_{\\mathbf{x}} \\dfrac{\\mathbf{\\mu}^{T}\\mathbf{x} - r_f }{||\\mathbf{G}^{T}\\mathbf{x}||_2}, \\]\nwhere we reformulated the risk term as a 2-norm as in the previous post.\nIn order to derive a conic formulation for the objective function above, we should not that if we could fix the term in the numerator\n\\[ \\mathbf{\\mu}^{T}\\mathbf{x} - r_{f} = \\text{const}, \\]\nthen the objective would be equivalent to minimizing \\(||\\mathbf{G}^{T}\\mathbf{x}||_2\\), which is a standard second-order cone problem.\nWe do not know in advance what the constant value should be. Solving this problem for all the possible constant values is equivalent to computing the efficient frontier. We do not want to do that, therefore let\u0026rsquo;s denote the constant value using a new scalar variable \\(z\\), \\(z\\geq 0\\), as \\(\\text{const}=1/z\\). In this way, we now have\n\\[ \\mathbf{\\mu}^{T}\\mathbf{x} - r_{f} = \\dfrac{1}{z} \\]\nThe reason for using \\(1/z\\) will become obvious in a moment. If we multiply both sides by \\(z\\), we obtain\n\\[z \\mathbf{\\mu}^{T}\\mathbf{x} - r_{f}z = 1 \\]\nDenoting \\(\\mathbf{y}=z\\mathbf{x}\\), this equation becomes\n\\[\\mathbf{\\mu}^{T}\\mathbf{y} - r_{f}z = 1 \\]\nGiven that \\(\\mathbf{x} = \\mathbf{y}/z\\), the objective function becomes\n\\[ \\dfrac{\\mathbf{\\mathbf{\\mu}^{T}\\mathbf{x} - r_{f}}}{||\\mathbf{G}^{T}\\mathbf{x}||_2}=\\dfrac{1/z}{||\\mathbf{G}^{T}\\mathbf{\\frac{y}{z}}||_2} = \\dfrac{1}{||\\mathbf{G}^{T}\\mathbf{y}||_2}, \\]\nwhich allows us to rewrite the original optimization problem as\n\\[ \\begin{array}{lr} \\text{minimize} \u0026amp; ||\\mathbf{G}^{T}\\mathbf{y}||_{2} \\\\ \\text{subject to} \u0026amp; \\mathbf{\\mu}^{T}\\mathbf{y} - r_f z = 1 \\\\ \u0026amp; z\\geq 0 \\end{array} \\]\nThe new problem involves variables \\(\\mathbf{y}\\) and \\(z\\), so any additional constraints must be rewritten by substituting \\(x=y/z\\). For instance, the budget constraint \\( \\mathbf{1}^{T}\\mathbf{x} = 1\\) is reformulated as\n\\[ \\mathbf{1}^{T}\\mathbf{y} = z, \\ \\ \\ y\\geq 0. \\]\nOn the other hand, diversification constraints of the form \\(l_{i} \\leq x_{i} \\leq u_{i}\\) are rewritten as\n\\[ zl_{i} \\leq y_{i} \\leq zu_{i} \\]\nFinally, a solution \\(y, z\\) to the reformulated optimization problem gives a solution \\(x=y/z\\) to the original problem.\nPython Implementation The implementation of the portfolio optimization problem in Python closely resembles the approach presented in our previous post. The primary distinction lies in the modification of variables to reframe the problem as a conic optimization problem.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 import mosek.fusion as mf from typing import List, Dict, Any import pandas as pd import numpy as np import yfinance as yf import altair as alt alt.renderers.set_embed_options(actions=False, theme=\u0026#34;dark\u0026#34;) def build_model( n_assets: int, asset_sectors: pd.DataFrame, constraints: List[Dict[str, Any]], risk_free: float = 0.0, ) -\u0026gt; mf.Model: \u0026#34;\u0026#34;\u0026#34; Function for building MOSEK model to solve the mean-variance optimization problem with diversification constraints. Parameters ---------- n_assets : int Number of assets in the investment universe. asset_sectors : pd.DataFrame DataFrame containing assets\u0026#39; names (`\u0026#34;Asset\u0026#34;` column) and their corresponding sectors (`\u0026#34;Sector\u0026#34;` column). constraints : List[Dict[str, Any]] List of diversification constraints (dictionaries). The dictionaries must have the following keys: - `\u0026#34;Type\u0026#34;`: type of constraint. It can be `\u0026#34;All Assets\u0026#34;` (the constraint applies to all the assets), `\u0026#34;Sectors\u0026#34;` (the constraint applies only to assets from a particular sector) or `\u0026#34;Assets\u0026#34;` (the constraint applies to a particular asset). - `\u0026#34;Weight\u0026#34;`: limit value for the assets\u0026#39; weights. - `\u0026#34;Sign\u0026#34;`: domain of the constraint. It can be `\u0026#34;\u0026gt;=\u0026#34;` (greater than) or `\u0026#34;\u0026lt;=\u0026#34;` (less than). - `\u0026#34;Position\u0026#34;`: indicates to which positions the constraint applies. It can be the name of a sector, the name of an asset or an empty string (`\u0026#34;\u0026#34;`) if the constraint type is `\u0026#34;All Assets\u0026#34;`. risk_free: float Risk free rate. Returns ------- model: mf.Model MOSEK model object. \u0026#34;\u0026#34;\u0026#34; # Creating the model model = mf.Model(\u0026#34;sharpe_ratio\u0026#34;) # Auxiliar vector variable y. y = model.variable(\u0026#34;y\u0026#34;, n_assets, mf.Domain.greaterThan(0.0)) # Auxiliar scalar variable z. z = model.variable(\u0026#34;z\u0026#34;, 1, mf.Domain.greaterThan(0.0)) # Variable for modeling the portfolio variance in the objective function s = model.variable(\u0026#34;s\u0026#34;, 1, mf.Domain.unbounded()) # Parameter for cov matrix decomposition. G = model.parameter(\u0026#34;G\u0026#34;, [n_assets, n_assets]) # Parameter for expected returns vector. mu = model.parameter(\u0026#34;mu\u0026#34;, n_assets) # Reformulation constraint model.constraint( \u0026#34;reformulation\u0026#34;, mf.Expr.sub(mf.Expr.dot(mu, y), mf.Expr.mul(risk_free, z)), mf.Domain.equalsTo(1.0), ) # Budget constraint (fully invested) model.constraint( \u0026#34;budget\u0026#34;, mf.Expr.sub(mf.Expr.sum(y), z), mf.Domain.equalsTo(0) ) # Iterate over the constraints list and add the constraints to the model. for c, constraint in enumerate(constraints): sign = ( mf.Domain.greaterThan(0.0) if constraint[\u0026#34;Sign\u0026#34;] == \u0026#34;\u0026gt;=\u0026#34; else mf.Domain.lessThan(0.0) ) if constraint[\u0026#34;Type\u0026#34;] == \u0026#34;All Assets\u0026#34;: A = np.identity(n_assets) model.constraint( f\u0026#34;c_{c}\u0026#34;, mf.Expr.sub( mf.Expr.mul(A, y), mf.Expr.mul( constraint[\u0026#34;Weight\u0026#34;], mf.Var.vrepeat(z, n_assets) ), ), sign, ) elif constraint[\u0026#34;Type\u0026#34;] == \u0026#34;Sectors\u0026#34;: A = np.where( asset_sectors.loc[:, \u0026#34;Sector\u0026#34;] == constraint[\u0026#34;Position\u0026#34;], 1.0, 0.0, ) model.constraint( f\u0026#34;c_{c}\u0026#34;, mf.Expr.sub( mf.Expr.dot(A, y), mf.Expr.mul( constraint[\u0026#34;Weight\u0026#34;], z ), ), sign, ) elif constraint[\u0026#34;Type\u0026#34;] == \u0026#34;Assets\u0026#34;: A = np.where( asset_sectors.loc[:, \u0026#34;Asset\u0026#34;] == constraint[\u0026#34;Position\u0026#34;], 1.0, 0.0, ) model.constraint( f\u0026#34;c_{c}\u0026#34;, mf.Expr.sub( mf.Expr.dot(A, y), mf.Expr.mul( constraint[\u0026#34;Weight\u0026#34;], z ), ), sign, ) # Conic constraint for the portfolio variance model.constraint( \u0026#34;risk\u0026#34;, mf.Expr.vstack(s, mf.Expr.mul(G, y)), mf.Domain.inQCone() ) # Define objective function model.objective( \u0026#34;obj\u0026#34;, mf.ObjectiveSense.Minimize, s, ) return model We will employ the identical investment universe and constraints as outlined in the previous post. Our objective is to obtain the vector variable \\(\\mathbf{y}\\) and the scalar variable \\(z\\), which will be utilized to derive the optimal portfolio weights by calculating their ratio.\n1 2 3 4 5 6 7 8 9 10 11 12 # Get optimal weights from the Model object. weights = pd.Series( constrained_model.getVariable(\u0026#34;y\u0026#34;).level() / constrained_model.getVariable(\u0026#34;z\u0026#34;).level()[0], index=asset_sectors.loc[:, \u0026#34;Asset\u0026#34;], name=\u0026#34;Constrained\u0026#34;, ).to_frame() weights.loc[:, \u0026#34;Unconstrained\u0026#34;] = ( unconstrained_model.getVariable(\u0026#34;y\u0026#34;).level() / unconstrained_model.getVariable(\u0026#34;z\u0026#34;).level()[0] ) The plot below illustrates the portfolio weights for both the constrained and unconstrained cases. Once again, we observe that the imposition of constraints leads to the selection of a greater number of assets.\nWe can utilize the following function to calculate the Sharpe Ratio of the portfolios and assess the influence of the constraints on its value.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def get_portfolio_sharpe_ratio( weights: np.ndarray | pd.Series, mu: np.ndarray | pd.Series, sigma: np.ndarray | pd.DataFrame, ann_factor: int = 252, ): \u0026#34;\u0026#34;\u0026#34; Computes the Annualized Sharpe Ratio. Parameters ---------- weights : np.ndarray | pd.Series Portfolio weights. mu : np.ndarray | pd.Series Expected return. sigma : np.ndarray | pd.DataFrame Covariance matrix. ann_factor : int, optional Annualization factor, by default 252. Returns ------- float Sharpe Ratio. \u0026#34;\u0026#34;\u0026#34; std_dev = np.sqrt( np.dot( np.dot( weights, sigma, ), weights, ) ) expected_return = np.dot( weights, mu, ) return (expected_return/std_dev)*np.sqrt(ann_factor) The constrained portfolio exhibits a Sharpe Ratio of 0.95, whereas the unconstrained version achieves a ratio of 1.10. It is important to note that these calculations rely on historical data, and future portfolio performance may deviate from these values. While the constrained portfolio\u0026rsquo;s Sharpe Ratio is lower than that of the unconstrained version, it is possible that the constraints have positively impacted other significant risk metrics. To further analyze this, a backtest will be performed, as detailed in the upcoming post.\nConclusion We have explored the use of the Sharpe Ratio in portfolio optimization and management, highlighting its benefits and limitations. The Sharpe Ratio provides a valuable metric for evaluating risk-adjusted returns and aiding investment decision-making. While it offers insights into portfolio efficiency, it is crucial to consider its assumptions and potential drawbacks.\nTo further deepen our analysis and gain a comprehensive understanding of the impact of constraints on portfolio performance, the next post will delve into the execution of a backtest. Using Python\u0026rsquo;s bt library, we will demonstrate how to conduct a thorough evaluation by simulating the historical performance of constrained and unconstrained portfolios. This will enable us to assess their risk-return trade-offs and gain valuable insights into the efficacy of the portfolio optimization strategies employed.\nYou can find the full code here in the sharpe_ratio.ipynb notebook.\nStay tuned for the next post, where we will explore the intricacies of backtesting and how it can enhance our understanding of portfolio performance in real-world scenarios.\n","permalink":"https://matimacazaga.github.io/posts/portfolio_optimization_max_sharpe/","summary":"This is the second part of the Portfolio Optimization with Python series. In Part I, we introduced the Portfolio Optimization field, the MVO framework and the MOSEK python API for solving a constrained portfolio optimization problem efficiently. This time, we will find the portfolio that maximizes a performance metric called Sharpe Ratio. We will first introduce the Sharpe Ratio and its benefits and drawbacks as a portfolio performance metric. Finally, we will formulate the optimization problem theoretically as a conic problem and solve it using Python.","title":"Portfolio Optimization with Python - Part II"},{"content":"This is the first part of the Portfolio Optimization with Python series. The intend is to make a deep dive into the field and study some real-world applications with Python. Throughout the series, I\u0026rsquo;ll be using MOSEK library for solving the optimization problems and Backtrader for backtesting the portfolio management strategies.\nThis time, I\u0026rsquo;ll make a brief introduction to the Markowitz Portfolio Optimization framework so you start to familiarize with the relevant concepts. At the end, I\u0026rsquo;ll show you a simple function building the Markowitz Mean-Variance portfolio using MOSEK and finding the optimal weights and efficient frontier.\nMarkowitz Portfolio Optimization Let\u0026rsquo;s consider an investor who wishes to allocate capital among \\(N\\) securities at time \\(t=0\\) and hold them over a single period of time \\(t=h\\). Moreover, assume that the investor is risk-averse, that is, he/she is looking to maximize the return of the investment while trying to keep the investment risk on an acceptable level. We can think of the risk as the uncertainty of the future portfolio returns.\nThe investment risk can be decomposed into two components: the specific risk and the systematic risk. We can\u0026rsquo;t do much with the systematic risk part: the only way of reducing it is by decreasing the expected return of the portfolio. On the other hand, the specific risk, or the risk associated with each of the securities in the portfolio, can be reduced through diversification for a fixed expected return. Markowitz Theory (also known as Modern Portfolio Theory) formalizes this process by using the variance as a measure of portfolio risk, and constructing an optimization problem whose solution are the optimal portfolio weights for the given inputs and constraints (more on this later).\nBefore I go any further, let me define some important quantities:\n\\(p_{0,i}\\): the known price of a security \\(i\\) at the beginning of the investment period. \\(P_{h,i}\\): the random price of the security \\(i\\) at the end of the investment period \\(h\\). The rate of return of the security \\(i\\) over the investment period \\(h\\), modeled by the random variable \\[R_{i}=\\dfrac{P_{h,i}}{p_{0,i}}-1\\]\nThe expected value of the rate of return of the security \\(i\\) \\[ \\mu_{i} = \\mathbb{E}(R_{i}) \\]\nThe portfolio vector \\(\\mathbf{x}\\in\\mathbb{R}^{N}\\), where \\(N\\) is the number of symbols and \\(x_{i}\\) is the proportion of funds invested into security \\(i\\). The random portfolio return \\[R_{\\mathbf{x}}=\\sum_{i}^{N}x_{i}R_{i}=\\mathbf{x}^{T}R,\\]\nwhere \\(\\mathbf{R}=[R_{1}, \\dots, R_{i}, \\dots, R_{N}]^{T}\\) is the vector of asset\u0026rsquo;s returns.\nThe expected portfolio return \\[\\mu_{\\mathbf{x}}=\\mathbb{E}(R_{\\mathbf{x}})=\\mathbf{x}^{T}\\mathbb{E}(R)=\\mathbf{x}^{T}\\mathbf{\\mu},\\]\nwhere \\(\\mathbf{\\mu}\\) is the vector of expected returns.\nThe portfolio variance \\[\\sigma_{\\mathbf{x}}^{2} = \\text{Var}(R_{\\mathbf{x}}) = \\sum_{i}^{N}\\text{Cov}(R_{i}, R_{j})x_{i}x_{j}=\\mathbf{x}^{T}\\mathbf{\\Sigma}\\mathbf{x},\\]\nwhere \\(\\mathbf{\\Sigma}\\) is the covariance matrix of returns.\nBased on these quantities, we can state the portfolio optimization problem defined above as\n\\[\\begin{array}{lr}\\text{minimize} \u0026amp; \\mathbf{x}^{T}\\mathbf{\\Sigma}\\mathbf{x}\\\\ \\text{subject to} \u0026amp; \\mathbf{\\mu}^{T}\\mathbf{x} \\geq r_{min} \\\\ \u0026amp; \\mathbf{1}^{T}\\mathbf{x} = 1\\end{array}\\]\nThat is, minimize the variance of the portfolio given a minimum required portfolio return \\(r_{min}\\) and the budget constraint \\(\\mathbf{1}^{T}\\mathbf{x} = \\sum_{i}^{N} x_{i} = 1\\), which means that the portfolio is fully invested. Given this, the optimization problem is also referred as Mean-Variance Optimization (MVO).\nUsing the input parameters \\(\\mathbf{\\mu}\\) and \\(\\mathbf{\\Sigma}\\), MVO seeks to find a portfolio of assets \\(\\mathbf{x}\\) in such a way that it seeks the optimal trade-off between expected portfolio return and portfolio risk. There are two alternative formulations to the problem statement given above:\nMaximize expected return for a risk level \\[ \\begin{array}{lr} \\text{maximize} \u0026amp; \\mathbf{\\mu}^{T}\\mathbf{x} \\\\ \\text{subject to} \u0026amp; \\mathbf{x}^{T}\\mathbf{\\Sigma x}\\leq \\gamma^{2} \\\\ \u0026amp; \\mathbf{1}^{T}\\mathbf{x} = 1,\\end{array} \\]\nwhere \\(\\gamma^{2}\\) is an upper bound on the portfolio risk.\nMaximize the utility function of the investor \\[ \\begin{array}{lr} \\text{maximize} \u0026amp; \\mathbf{\\mu}^{T}\\mathbf{x} - \\dfrac{\\delta}{2}\\mathbf{x}^{T}\\mathbf{\\Sigma x} \\\\ \\text{subject to} \u0026amp; \\mathbf{1}^{T}\\mathbf{x} = 1,\\end{array} \\]\nwhere \\(\\delta\\) is the risk-aversion coefficient. The problem with this formulation is that the risk coefficient does not have an intuitive investment meaning for the investor. However, if we reformulate the problem using the standard deviation\n\\[ \\begin{array}{lr} \\text{maximize} \u0026amp; \\mathbf{\\mu}^{T}\\mathbf{x} - \\tilde{\\delta}\\sqrt{\\mathbf{x}^{T}\\mathbf{\\Sigma x}} \\\\ \\text{subject to} \u0026amp; \\mathbf{1}^{T}\\mathbf{x} = 1,\\end{array} \\label{9} \\]\nand assume that the portfolio return is normally distributed, then \\(\\tilde{\\delta}\\) is the z-score of portfolio return, that is, the distance from the mean measured in units of standard deviation. We can see that for \\(\\tilde{\\delta}=0\\), we maximize expected portfolio return. Then, by increasing \\(\\tilde{\\delta}\\), we put more and more weight on tail risk, i.e., we maximize a lower and lower quantile of portfolio return.\nAll the formulations above will result in the same set of optimal solutions. The optimal portfolio \\(\\mathbf{x}\\) is said to be efficient in the sense that there is no other portfolio giving a strictly higher return for the same amount of risk (variance). The collection of such points (portfolios) is known as the efficient frontier in the mean return-variance space.\nWe can use the method of Lagrangian multipliers to obtain a closed-form solution for the optimization problem above. However, in the investment practice it is common to include additional constraints in the form of linear and convex equalities or inequalities. Examples of constraints are diversification constraints, leverage constraints, turnover constraints, among others. Furthermore, extra objective function terms can be included for representing restrictions on the optimal weights. In these more realistic use cases, it is compulsory to use numerical optimization algorithms for finding the optimal solution.\nDiversification constraints We will focus our attention on diversification constraints, which help to limit portfolio risk by restricting the exposure to individual positions or sectors.\nFor a single position \\(i\\), we have\n\\[ l_{i} \\leq x_{i} \\leq u_{i}, \\]\nwhere \\(l_{i}\\) is the lower bound and \\(u_{i}\\) the upper one.\nOn the other hand, for a sector or group of assets \\(\\mathbb{I}\\), we have\n\\[ l_{i} \\leq \\sum_{i\\in\\mathbb{I}}x_{i}\\leq u_{i} \\]\nNote that the constraints of the type greater than (similar for constraints of the type less than) that apply to all the assets can be expressed in matrix form as\n\\[ \\mathbb{I}^{N\\times N} \\mathbf{x} \\leq \\mathbf{1}_{N} u \\]\nwhere \\(\\mathbb{I}^{N\\times N}\\) is the identity matrix with \\(N\\) columns and rows, \\(\\mathbf{1}_{N}\\) is an \\(N\\)-dimensional vector of ones and \\(u\\) is the upper bound.\nAdditionally, greater than constraints (similar for less than constraints) for assets in a specific sector can be expressed as\n\\[ \\mathbf{1}_{i\\in\\mathbb{I}}^{T}\\mathbf{x} \\leq u \\]\nwhere \\(\\mathbf{1}_{i\\in\\mathbb{I}}^{T}\\) is an \\(N\\)-dimensional vector whose values are \\(1\\) if the asset \\(i\\) belongs to the sector \\(\\mathbb{I}\\) or \\(0\\) if not.\nFinally, greater than (or similarly less than) constraints for a specific asset can be expressed as\n\\[\\mathbf{1}_{i=j}^{T}\\mathbf{x} \\leq u \\]\nwhere \\(\\mathbf{1}_{i=j}^{T}\\mathbf{x}\\) is an \\(N\\)-dimensional vector whose values are \\(1\\) only for the asset \\(j\\) of interest\nConic formulation The portfolio optimization problems stated above are quadratic optimization (QO) problems. Solving QO in their original form is popular and considered easy. However, more recent results showed that conic optimization models can improve QO models both in the theoretical and in the practical sense.\nConic (quadratic) optimization, also known as second-order cone optimization, is a straightforward generalization of linear optimization, meaning that we optimize a linear function under linear (in)equalities with some variables belonging to one or more quadratic cones.\nAn \\(n\\)-dimensional quadratic cone is defined as\n\\[ \\mathcal{Q}^{n} = \\left\\{ x \\in \\mathbb{R}^{n} | x_{1} \\geq \\sqrt{x_{2}^{2} + x_{3}^{2} + \\cdots + x_{n}^{2}} \\right\\} \\]\nExample of the geometric interpretation of a quadratic cone and a rotated quadratic cone (not discussed here) with three variables. source\nHaving this in mind and assuming that the covariance matrix \\( \\mathbf{\\Sigma} \\) is positive definite such that\n\\[ \\mathbf{\\Sigma} = \\mathbf{G}\\mathbf{G}^{T}, \\ \\ \\ \\mathbf{G}\\in\\mathbb{R}^{N\\times k}\\]\nwe can write the portfolio variance as\n\\[ \\mathbf{x}^{T}\\mathbf{\\Sigma x} = \\mathbf{x}^{T}\\mathbf{G}\\mathbf{G}^{T}x = ||\\mathbf{G}^{T}\\mathbf{x}||_{2}^{2}. \\]\nWe can find the conic equivalent of the problem in Eq. \\( (\\ref{9})\\) by introducing a variable \\(s\\) to represent the upper bound of the portfolio standard deviation, and model the constraint \\( ||\\mathbf{G}^{T}\\mathbf{x}||_{2}\\leq s \\) using the quadratic cone as\n\\[ \\begin{array}{lr} \\text{maximize} \u0026amp; \\mathbf{\\mu}^{T}\\mathbf{x} - \\tilde{\\delta}s \\\\ \\text{subject to} \u0026amp; \\left(s, \\mathbf{G}^{T}\\mathbf{x}\\right) \\in \\mathcal{Q}^{k+1} \\\\ \u0026amp; \\mathbf{1}^{T}\\mathbf{x} = 1 \\label{15} \\end{array} \\]\nSolving the problem in this format will result in a more robust, faster and reliable solution process.\nPython implementation Enough theory for now, let\u0026rsquo;s code! We\u0026rsquo;ll be using MOSEK\u0026rsquo;s Fusion API for solving the optimization problem. MOSEK is an interior-point optimizer for linear, quadratic and conic optimization problems that is employed by several technological, financial and educational institutions. Fusion is an object-oriented API designed for building conic optimization models in a simple and expressive manner.\nIn the Fusion API, the user\u0026rsquo;s interface to the optimization problem is the Model object. The Model class is used for\nformulating the problem by defining Variables, Parameters, constraints and the objective functions, solving the problem and retrieving the solution status and solutions, interacting with the solver. Let\u0026rsquo;s define a function for building a Fusion Model that represents the problem from Eq. \\( (\\ref{15})\\). The function will receive the following inputs:\nn_assets: number of assets in the investment universe. asset_sectors: pandas DataFrame containing a column with the assets names (\u0026quot;Asset\u0026quot;) and another with their corresponding sector (\u0026quot;Sector\u0026quot;). constraints: List of constraints. The constraints will be dictionaries containing the following keys: \u0026quot;Type\u0026quot;: type of constraint. It can be \u0026quot;All Assets\u0026quot; (the constraint applies to all the assets), \u0026quot;Sectors\u0026quot; (the constraint applies only to assets from a particular sector) or \u0026quot;Assets\u0026quot; (the constraint applies to a particular asset). \u0026quot;Weight\u0026quot;: limit value for the assets\u0026rsquo; weights. \u0026quot;Sign\u0026quot;: domain of the constraint. It can be \u0026quot;\u0026gt;=\u0026quot; (greater than) or \u0026quot;\u0026lt;=\u0026quot; (less than). \u0026quot;Position\u0026quot;: indicates to which positions the constraint applies. It can be the name of a sector, the name of an asset or an empty string (\u0026quot;\u0026quot;) if the constraint type is \u0026quot;All Assets\u0026quot;. You\u0026rsquo;ll find examples of asset_sectors and constraints below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 import mosek.fusion as mf from typing import List, Dict, Any import pandas as pd import numpy as np import altair as alt import yfinance as yf def build_model( n_assets: int, asset_sectors:pd.DataFrame, constraints:List[Dict[str, Any]], )-\u0026gt;mf.Model: # Creating the model model = mf.Model(\u0026#34;markowitz_MV\u0026#34;) # Weights variable with no-short-selling constraint. x = model.variable(\u0026#34;x\u0026#34;, n_assets, mf.Domain.greaterThan(0.0)) # Variable for modeling the portfolio variance in the objective function s = model.variable(\u0026#34;s\u0026#34;, 1, mf.Domain.unbounded()) # Parameter for cov matrix decomposition. G = model.parameter(\u0026#34;G\u0026#34;, [n_assets, n_assets]) # Parameter for expected returns vector. mu = model.parameter(\u0026#34;mu\u0026#34;, n_assets) # delta parameter delta = model.parameter(\u0026#34;delta\u0026#34;) # Budget constraint (fully invested) model.constraint(\u0026#34;budget\u0026#34;, mf.Expr.sum(x), mf.Domain.equalsTo(1)) # Iterate over the constraints list and add the constraints to the model. for c, constraint in enumerate(constraints): sign = ( mf.Domain.greaterThan(constraint[\u0026#34;Weight\u0026#34;]) if constraint[\u0026#34;Sign\u0026#34;] == \u0026#34;\u0026gt;=\u0026#34; else mf.Domain.lessThan(constraint[\u0026#34;Weight\u0026#34;]) ) if constraint[\u0026#34;Type\u0026#34;] == \u0026#34;All Assets\u0026#34;: A = np.identity(n_assets) model.constraint( f\u0026#34;c_{c}\u0026#34;, mf.Expr.mul( A, x ), sign ) elif constraint[\u0026#34;Type\u0026#34;] == \u0026#34;Sectors\u0026#34;: A = np.where( asset_sectors.loc[:, \u0026#34;Sector\u0026#34;] == constraint[\u0026#34;Position\u0026#34;], 1., 0. ) model.constraint( f\u0026#34;c_{c}\u0026#34;, mf.Expr.dot(A, x), sign ) elif constraint[\u0026#34;Type\u0026#34;] == \u0026#34;Assets\u0026#34;: A = np.where( asset_sectors.loc[:, \u0026#34;Assets\u0026#34;] == constraint[\u0026#34;Position\u0026#34;], 1., 0. ) model.constraint( f\u0026#34;c_{c}\u0026#34;, mf.Expr.dot(A, x), sign ) # Conic constraint for the portfolio variance model.constraint( \u0026#34;risk\u0026#34;, mf.Expr.vstack( s, mf.Expr.mul(G, x) ), mf.Domain.inQCone() ) # Define objective function model.objective( \u0026#34;obj\u0026#34;, mf.ObjectiveSense.Maximize, mf.Expr.sub( mf.Expr.dot(mu, x), mf.Expr.mul(delta, s) ) ) return model Let me walk you through the code above:\nLine 15 instantiate the Model object. Lines 18 and 21 create the optimization variables x (portfolio weights) and s (upper bound of the portfolio variance). For creating a variable, we first need to pass the variable\u0026rsquo;s name, then the dimension (1 for scalars) and lastly, the domain. The domain can be unbounded if there is no restriction; or greaterThan or lessThan if there are lower and upper bounds. Lines 24 and 27 create the parameters for the covariance matrix decomposition G and the expected returns vector mu. We will later set the values of these parameters using real data. Defining both G and mu as parameters is very handy because we can compare different estimation methods without the need of re-building the model. As you can see, parameters are created in a similar way than variables, passing first the name and then the dimension. Line 30 defines the delta parameter for the objective function. We will later try different values for it. Note that delta is a scalar, so we don\u0026rsquo;t need to pass the dimension in this case. Line 33 set the budget constraint. A constraint is set by passing the name, the mathematical expression and the domain (equality or inequality). Note that the Fusion API has several expressions for performing summation, simple and matrix multiplication, dot product, etc. You can see a complete list in Section 6.3 of MOSEK\u0026rsquo;s documentation. Lines 36 through 83 set the constraints by asset/s and sector/s. Lines 86 through 93 set the conic constraint for the portfolio variance. Note that G is not transpose here, so we will need to take care of this when setting its value. Lines 96 through 103 define the objective function of the problem. Now, let\u0026rsquo;s define the investment universe and grab some historical data from Yahoo Finance for estimating the covariance matrix and the vector of expected returns. We will use the yfinance package for downloading the data.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 asset_sectors = pd.DataFrame( { \u0026#34;Asset\u0026#34;: [ \u0026#34;NVDA\u0026#34;, \u0026#34;AMD\u0026#34;, \u0026#34;INTC\u0026#34;, \u0026#34;BAC\u0026#34;, \u0026#34;JPM\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;MSFT\u0026#34;, \u0026#34;GOOG\u0026#34;, \u0026#34;META\u0026#34;, \u0026#34;BTC-USD\u0026#34;, \u0026#34;ETH-USD\u0026#34;, ], \u0026#34;Sector\u0026#34;: [ \u0026#34;Electronic Technology\u0026#34;, \u0026#34;Electronic Technology\u0026#34;, \u0026#34;Electronic Technology\u0026#34;, \u0026#34;Finance\u0026#34;, \u0026#34;Finance\u0026#34;, \u0026#34;Finance\u0026#34;, \u0026#34;Technology Services\u0026#34;, \u0026#34;Technology Services\u0026#34;, \u0026#34;Technology Services\u0026#34;, \u0026#34;Crypto\u0026#34;, \u0026#34;Crypto\u0026#34; ] } ) assets_data = yf.download(asset_sectors.loc[:, \u0026#34;Asset\u0026#34;].to_list()) For now, we will use the sample estimates for the covariance matrix and expected returns vector. We will see in later posts how we can improve the estimation of these input parameters, which is an important topic because the optimization is highly sensible to them. The covariance matrix decomposition will be computed using the Cholesky\u0026rsquo;s decomposition.\n1 2 3 4 5 6 7 8 9 10 11 12 13 assets_returns = ( assets_data.loc[:, \u0026#34;Adj Close\u0026#34;] .pct_change() .loc[:, asset_sectors.loc[:, \u0026#34;Asset\u0026#34;]] ) sigma = assets_returns.cov() mu = assets_returns.mean() G = pd.DataFrame( np.linalg.cholesky(sigma), index=sigma.index, columns=sigma.columns ) We\u0026rsquo;ll impose the following constraints:\nNo asset will take more than \\(20\\%\\) of the portfolio. We want to invest at least \\(30\\%\\) and no more than \\(40\\%\\) of our wealth in the Electronic Technology sector. We don\u0026rsquo;t want META to take more than \\(5\\%\\) of the portfolio. We want to invest no more than \\(10\\%\\) in Crypto. The python version of this constraints is as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 constraints = [ {\u0026#34;Type\u0026#34;: \u0026#34;All Assets\u0026#34;, \u0026#34;Weight\u0026#34;: 0.2, \u0026#34;Sign\u0026#34;: \u0026#34;\u0026lt;=\u0026#34;, \u0026#34;Position\u0026#34;: \u0026#34;\u0026#34;}, { \u0026#34;Type\u0026#34;: \u0026#34;Sectors\u0026#34;, \u0026#34;Weight\u0026#34;: 0.3, \u0026#34;Sign\u0026#34;: \u0026#34;\u0026gt;=\u0026#34;, \u0026#34;Position\u0026#34;: \u0026#34;Electronic Technology\u0026#34;, }, { \u0026#34;Type\u0026#34;: \u0026#34;Sectors\u0026#34;, \u0026#34;Weight\u0026#34;: 0.4, \u0026#34;Sign\u0026#34;: \u0026#34;\u0026lt;=\u0026#34;, \u0026#34;Position\u0026#34;: \u0026#34;Electronic Technology\u0026#34;, }, { \u0026#34;Type\u0026#34;: \u0026#34;Assets\u0026#34;, \u0026#34;Weight\u0026#34;: 0.05, \u0026#34;Sign\u0026#34;: \u0026#34;\u0026lt;=\u0026#34;, \u0026#34;Position\u0026#34;: \u0026#34;META\u0026#34;, }, { \u0026#34;Type\u0026#34;: \u0026#34;Sectors\u0026#34;, \u0026#34;Weight\u0026#34;: 0.1, \u0026#34;Sign\u0026#34;: \u0026#34;\u0026lt;=\u0026#34;, \u0026#34;Position\u0026#34;: \u0026#34;Crypto\u0026#34;, }, ] We are now ready to build the model, set the values of the required parameters and solve the optimization problem. We\u0026rsquo;ll set delta=0.1. For the sake of comparison, we will also solve the unconstrained problem (only considering no short-selling).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 n_assets = len(asset_sectors) # Build constrained model constrained_model = build_model(n_assets, asset_sectors, constraints) # Set required parameters. constrained_model.getParameter(\u0026#34;G\u0026#34;).setValue(G.to_numpy().T) # Remember to transpose G. constrained_model.getParameter(\u0026#34;mu\u0026#34;).setValue(mu.to_numpy()) constrained_model.getParameter(\u0026#34;delta\u0026#34;).setValue(0.1) # Solve optimization problem. constrained_model.solve() # Get optimal weights from the Model object. weights = pd.Series( constrained_model.getVariable(\u0026#34;x\u0026#34;).level(), index=asset_sectors.loc[:, \u0026#34;Asset\u0026#34;], name=\u0026#34;Constrained\u0026#34; ).to_frame() # Build unconstrained model unconstrained_model = build_model(n_assets, asset_sectors, []) # Set required parameters. unconstrained_model.getParameter(\u0026#34;G\u0026#34;).setValue(G.to_numpy().T) # Remember to transpose G. unconstrained_model.getParameter(\u0026#34;mu\u0026#34;).setValue(mu.to_numpy()) unconstrained_model.getParameter(\u0026#34;delta\u0026#34;).setValue(0.1) # Solve optimization problem. unconstrained_model.solve() # Get optimal weights from the Model object. weights.loc[:, \u0026#34;Unconstrained\u0026#34;] = unconstrained_model.getVariable(\u0026#34;x\u0026#34;).level() In the figure below, we can see that the constrained version selected a greater amount of assets and assigned lower weights to them, which helps to improve portfolio diversification.\nAdditionally, we can easily check that all the constraints are met.\nFinally, we can compute the efficient frontier by solving the problem for different values of delta.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 deltas = np.linspace(0.01, 5, 100) efficient_frontier = [] for d in deltas: constrained_model.getParameter(\u0026#34;delta\u0026#34;).setValue(d) constrained_model.solve() w = constrained_model.getVariable(\u0026#34;x\u0026#34;).level() portf_exp_return = np.dot(mu, w) * 252 portf_volatility = constrained_model.getVariable(\u0026#34;s\u0026#34;).level()[0] * np.sqrt(252) efficient_frontier.append([portf_volatility, portf_exp_return, *list(w)]) efficient_frontier = pd.DataFrame( efficient_frontier, columns=[ \u0026#34;volatility\u0026#34;, \u0026#34;expected_return\u0026#34;, *asset_sectors.loc[:, \u0026#34;Asset\u0026#34;].to_list(), ], ) efficient_frontier.head() Hover your mouse over the plot and zoom-in to see the weights of each portfolio in the frontier.\nConclusion In this post we went through the fundamental concepts of Markowitz Portfolio Optimization and solved the constrained mean-variance optimization problem with the help of MOSEK\u0026rsquo;s Fusion API. By using real market data, we confirmed that including weight constraints helps to improve portfolio diversification (and thus lowering specific risk). In the next posts, we will solve a different problem: maximize portfolio\u0026rsquo;s risk-adjusted return measured by the Sharpe Ratio. Additionally, we will perform a backtesting to analyze strategy\u0026rsquo;s performance. You can find the full code here in the markowitz_mv.ipynb notebook. Stay tuned for more!\n","permalink":"https://matimacazaga.github.io/posts/portfolio_optimization/","summary":"This is the first part of the Portfolio Optimization with Python series. The intend is to make a deep dive into the field and study some real-world applications with Python. Throughout the series, I\u0026rsquo;ll be using MOSEK library for solving the optimization problems and Backtrader for backtesting the portfolio management strategies.\nThis time, I\u0026rsquo;ll make a brief introduction to the Markowitz Portfolio Optimization framework so you start to familiarize with the relevant concepts.","title":"Portfolio Optimization with Python - Part I"},{"content":"There are many good reasons to have a personal blog or website. For instance, it is an excellent way of showcasing your skills and sharing knowledge with your partners.\nTools like Wordpress and Wix allow you to easily create your first blog. However, they can be costly to maintain and configure. For this reason, I will show you in this post the same process I followed to create and deploy this website for free using Hugo and Github Pages.\nWhat is Hugo? HUGO Web Framework\nHugo is an open-source static site generator written in Go. It is used to build content-focussed websites in a flexible and fast manner (if you don\u0026rsquo;t believe me, just watch this YouTube tutorial). Although Hugo sites are highly customizable, you do not need any advanced programming skill to work with it.\nHugo has support for Markdown, an easy-to-use markup language that makes your life easier for writing content. However, the magic does not end here. Hugo comes with built-in shortcodes, which are code snippets you can utilize inside your Markdown content files for using custom templates. Hugo will render the shortcode using a predefined template, circumventing the need of using raw HTML code. An example of this is the rounded image of the Hugo logo shown above that contains a nicely displayed caption.\nThe last feature I would like to highlight is that Hugo has supports for themes. You can choose one from the official list and start adding your content with little effort.\nWhat is GitHub Pages? GitHub - source\nGitHub pages are public web pages for users and organizations that are freely hosted on Github\u0026rsquo;s github.io domain or on a custom domain name. GitHub Pages allows to create an entire website directly from a repository on GitHub.com.\nGitHub Pages basically takes HTML, CSS and JS files from a repository, runs them through a build process, and publishes the website.\nCreating your blog Prerequisites There are some prerequisites you need to fulfill before start working with Hugo and GithubPages:\nA GitHub Account for creating the site\u0026rsquo;s repository. Git for managing the project. Some familiarity with Markdown. Don\u0026rsquo;t worry, Markdown is simple and easy to learn. Installing Hugo Hugo supports multiple platforms. Below you can find quick installation instructions depending on your OS.\nmacOs and Linux If you are on macOS or Linux, you can install Hugo with the following one-liner thanks to Homebrew:\n1 brew install hugo Windows On Windows, you need to install Chocolatey first and then type the following on the PowerShell:\n1 choco install hugo-extended -confirm You can check Hugo\u0026rsquo;s installation by using\n1 hugo version Create a GitHub repository The next step is creating a GitHub repository. Go to this and login if necessary. Name the new repository \u0026lt;username\u0026gt;.github.io so your website is published at https://\u0026lt;username\u0026gt;.github.io. Set the visibility to Public and initialize the repository without a README and MIT License.\nOnce the repository is created, clone it to your local computer and open it in VS Code (or your IDE of preference).\nCreate a Hugo Project For creating a new Hugo project, open the terminal in the same folder of your repository, and type the following\n1 hugo new site ./ --force The --force argument is used because the folder we are using is not empty (we already have the license in there).\nBy default, Hugo uses TOML for configuration, but you can change to YAML by adding -f yml to the command above. The format of the configuration file will depend on the theme you choose (More on this below).\nYou will see that several new folders will be created. Now, we are ready for installing one of the gorgeous themes available.\nInstalling a theme As mentioned above, you can use a theme from the Hugo library. The initial configuration will vary from one theme to another, but fortunately most of them have a very good documentation page.\nThis time, I will be showing how to setup the PaperMod theme (the one I\u0026rsquo;m currently using). From the official documentation, we can see that there are several methods for installing/updating the theme. I used the second method, but you can choose what best suits your needs.\n1 2 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) The theme files will be included in the theme folder. Next step is to change the config.yml file. From the same documentation page, we can copy and paste the required settings. Additionally, you can find a description of the main features of the theme in this post and detailed information of the available variables here.\nRunning your website locally For running your website locally and checking that the theme is working, use:\n1 hugo server and open https://localhost:1313/ in your web browser. A handy feature of Hugo is that whenever you update something in your blog, it will be reflected on the site automatically as long as the hugo server process is running.\nFor adding your first blog post, you need to create a post.md file in the archetypes folder with the following content, which will serve as a starting base for all your blog posts.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 --- title: \u0026#34;My 1st post\u0026#34; date: 2020-09-15T11:30:03+00:00 # weight: 1 # aliases: [\u0026#34;/first\u0026#34;] tags: [\u0026#34;first\u0026#34;] author: \u0026#34;Me\u0026#34; # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors showToc: true TocOpen: false draft: false hidemeta: false comments: false description: \u0026#34;Desc Text.\u0026#34; canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableHLJS: true # to disable highlightjs disableShare: false disableHLJS: false hideSummary: false searchHidden: true ShowReadingTime: true ShowBreadCrumbs: true ShowPostNavLinks: true ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- Then, create a new folder called posts under the content folder. You can now automatically create posts using the following hugo command:\n1 hugo new --kind post content/posts/\u0026lt;name\u0026gt; This creates a new file in the content/posts folder that can be used as base for your blog post. Put some text in there and hit save to see the changes on the site.\nGenerate and publish the website You need to make some extra changes before being ready for publishing your website. In the config.yml, modified the baseurl parameter using your website name:\n1 baseurl = \u0026#34;https://username.github.io\u0026#34; After doing that, create a gh-pages.yml file under .github/workflows folder (create the folder and sub-folder if necessary).\nNOTE: make sure to include the \u0026ldquo;.\u0026rdquo; before github in the .github/workflows folder.\nCopy the following lines inside the gh-pages.yml file:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 name: Deploy Hugo to Pages on: push: paths-ignore: - \u0026#34;images/**\u0026#34; - \u0026#34;LICENSE\u0026#34; - \u0026#34;README.md\u0026#34; branches: - main workflow_dispatch: # manual run inputs: hugoVersion: description: \u0026#34;Hugo Version\u0026#34; required: false default: \u0026#34;0.83.0\u0026#34; # Allow one concurrent deployment concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: true # Default to bash defaults: run: shell: bash # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: \u0026#34;0.83.0\u0026#34; steps: - name: Check version if: ${{ github.event.inputs.hugoVersion }} run: export HUGO_VERSION=\u0026#34;${{ github.event.inputs.hugoVersion }}\u0026#34; - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_${HUGO_VERSION}_Linux-64bit.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Checkout uses: actions/checkout@v3 # with: # ref: exampleSite - name: Setup Pages id: pages uses: actions/configure-pages@v1 - name: Get Theme run: git submodule update --init --recursive - name: Update theme to Latest commit run: git submodule update --remote --merge - name: Build with Hugo run: | hugo \\ --buildDrafts --gc --verbose \\ --baseURL ${{ steps.pages.outputs.base_url }} - name: Upload artifact uses: actions/upload-pages-artifact@v1 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v1 Next, we are ready to generate the website by typing hugo in the command line. All your website files will be placed on the public folder. Commit and push the changes to the GitHub repository.\nFinally, go to your repository page and navigate to Settings -\u0026gt; Pages and under the Source option select GitHub Actions. Wait a few seconds until your site is deployed (you can check the deployment progress in the Actions tab) and visit it to check everything is correctly displayed.\nConclusion This is how you can create a personal website using Hugo and GitHub Pages. Best of all, after you went through all the initial setup, all you have to worry about is finding content for writing your new posts. Reach me out if you have any doubts or comments. Happy blogging!\nMain Resources Hugo and Github Pages PaperMod Theme by adityatelange Host Hugo on GitHub ","permalink":"https://matimacazaga.github.io/posts/hugo_tutorial/","summary":"There are many good reasons to have a personal blog or website. For instance, it is an excellent way of showcasing your skills and sharing knowledge with your partners.\nTools like Wordpress and Wix allow you to easily create your first blog. However, they can be costly to maintain and configure. For this reason, I will show you in this post the same process I followed to create and deploy this website for free using Hugo and Github Pages.","title":"Start a blog using Hugo and Github Pages"},{"content":"Hey all ! Welcome to my personal blog! My name is Matias Macazaga and I\u0026rsquo;m from Argentina. I\u0026rsquo;m a Quantitative Developer/Data Scientist with experience in Machine Learning models validation, development and deployment, Portfolio Management and Optimization, and Risk Management.\nFeel free to contact me at mdmacazaga@gmail.com or by LinkedIn.\n","permalink":"https://matimacazaga.github.io/about/","summary":"Hey all ! Welcome to my personal blog! My name is Matias Macazaga and I\u0026rsquo;m from Argentina. I\u0026rsquo;m a Quantitative Developer/Data Scientist with experience in Machine Learning models validation, development and deployment, Portfolio Management and Optimization, and Risk Management.\nFeel free to contact me at mdmacazaga@gmail.com or by LinkedIn.","title":""}]